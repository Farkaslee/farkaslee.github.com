1. java中有几种方法可以实现一个线程？

使用Runnable，Callable，Thread或者线程池

2. 如何停止一个正在运行的线程？

可以使用正在运行的线程，支持线程中断，通常是定义一个volatile的状态变量，在运行线程线程中读这个变量，其它线程中修改这个变量

3.sleep和wait有什么区别

sleep方法是在指定的时间内让正在执行的线程暂停执行，但不会释放锁。而wait方法是让当前线程等待，直到其他线程调用对象的notify或notifyAll方法。wait方法会释放掉锁，使别的线程有机会占用锁

4.notify()和notifyAll()有什么区别？

notify是随机唤醒一个等待某个资源的线程，进入就绪队列等待CPU的调度，notifyAll是唤醒所有的，进入就绪队列等待CPU调度

5.介绍下daemon线程

在Java中有两类线程：User Thread(用户线程)、Daemon Thread(守护线程) 。Daemon的作用是为其他线程的运行提供便利服务，比如垃圾回收线程就是一个很称职的守护者。User和Daemon两者几乎没有区别，唯一的不同之处就在于虚拟机的离开：如果 User Thread已经全部退出运行了，只剩下Daemon Thread存在了，虚拟机也就退出了。

6.乐观锁和悲观锁的理解及如何实现，有哪些实现方式

乐观锁，每次操作时不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止

悲观锁是会导致其它所有需要锁的线程挂起，等待持有锁的线程释放锁。

乐观锁可以使用volatile+CAS原语实现

悲观锁可以使用synchronize的以及Lock

7.如何让一段程序并发的执行，并最终汇总结果？

使用CyclicBarrier 在多个关口处将多个线程执行结果汇总 ；CountDownLatch 在各线程执行完毕后向总线程汇报结果

8.如何合理的配置java线程池？如CPU密集型的任务或IO密集型的任务，基本线程池应该配置多大？

CPU密集型任务可以少配置线程数，大概和机器的cpu核数相当，可以使得每个线程都在执行任务；IO密集型时，大部分线程都阻塞，故需要多配置线程数，2*cpu核数

9.多读少写的场景应该使用哪个并发容器，为什么使用它？

CopyOnWriteArrayList这个容器适用于多读少写。读写并不是在同一个对象上。在写时会大面积复制数组，所以写的性能差，在写完成后将读的引用改为执行写的对象。

10.如何实现乐观锁（CAS）？如何避免ABA问题？

1.CAS原语有三个值，一个是内存值，一个是期望值，一个是写入值。 在不加锁的情况下写入时，每次读取内存值，然后跟预期值比对，如果比对失败，反复的读和比对，直到成功。在CAS原语是一个原子操作，如果写入时，内存值发生改变，则写入值失败。

2.带参数版本来避免aba问题，在读取和替换的时候进行判定版本是否一致

11.什么场景下可以使用volatile替换synchronized？

只需要保证共享资源的可见性的时候可以使用volatile替代，synchronized保证可操作的原子性一致性和可见性。 volatile适用于新值不依赖于就值的情形

12.什么是可重入锁（ReentrantLock）？

ReentrantLock 相对于固有锁synchronized，同样是可重入的，在某些vm版本上提供了比固有锁更高的性能，提供了更丰富的锁特性，比如可中断的锁，可等待的锁，平等锁以及非块结构的加锁。从代码上尽量用固有锁，vm会对固有锁做一定的优化，并且代码可维护和稳定。只有在需要ReentrantLock的一些特性时，可以考虑用ReentrantLock实现。

13.ReentrantLock 和synchronized比较。来自《java并发编程实战》

1.为什么JUC框架出现LOCK？

ReentrantLock并不是替代synchronized的方法，而是当内置锁不适用时，作为一种可选的高级功能。

2.那么Synchronized有哪些缺点？

①. 只有一个condition与锁相关联，这个condition是什么？就是synchronized对针对的对象锁。

②. synchronized无法中断一个正在等待获得锁的线程，也即多线程竞争一个锁时，其余未得到锁的线程只能不停的尝试获得锁，而不能中断。这种情况对于大量的竞争线程会造成性能的下降等后果。

3.我们面对ReentrantLock和synchronized改如何选择？

Synchronized相比Lock，为许多开发人员所熟悉，并且简洁紧凑，如果现有程序已经使用了内置锁，那么尽量保持代码风格统一，尽量不引入Lock，避免两种机制混用，容易令人困惑，也容易发生错误。

在Synchronized无法满足需求的情况下，Lock可以作为一种高级工具，这些功能包括“可定时的、可轮询的与可中断的锁获取操作，公平队列，以及非块结构的锁”否则还是优先使用Synchronized。

最后，未来更可能提升Synchronized而不是Lock的性能，因为Synchronized是JVM的内置属性，他能执行一些优化，例如对线程封闭的锁对象的锁消除优化，通过增加锁的粒度来消除内置锁的同步，而如果基于类库的锁来实现这些功能，则可能性不大。

14.volatile是否能保证数组中元素的可见性

volatile的数组只针对数组的引用具有volatile的语义，而不是它的元素
